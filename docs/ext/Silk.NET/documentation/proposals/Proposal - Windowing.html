<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Summary </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Summary ">
    <meta name="generator" content="docfx 2.56.1.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="">
    <meta property="docfx:tocrel" content="">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="summary">Summary</h1>

<ul>
<li>API proposal for Silk.NET.Windowing.</li>
</ul>
<h1 id="contributors">Contributors</h1>
<ul>
<li>Aaron P, Ultz</li>
<li>Dylan P, Ultz</li>
<li>Jarl G, Firwood Software</li>
<li>Void, Silk.NET Codeowners</li>
</ul>
<h1 id="current-status">Current Status</h1>
<ul>
<li>[x] Proposed</li>
<li>[x] Discussed with API Review Board (ARB)</li>
<li>[x] Approved</li>
<li>[x] Implemented</li>
</ul>
<h1 id="design-decisions">Design Decisions</h1>
<ul>
<li><p>I was dissatisfied with the windowing system I worked on, primarily because I felt it was too large and bloated. It suffered from attempting to recreate an older API, instead of being a true new beginning. With this proposal, I hope to create a new API that feels familiar, but is much cleaner and easier to work with.</p>
</li>
<li><p>Our current mathematics library, <code>System.Numerics</code>, does not provide support for a few important types, most notably integer vectors. For now, Points and Sizes are used instead.</p>
</li>
</ul>
<h1 id="proposed-api">Proposed API</h1>
<h2 id="interfaces">Interfaces</h2>
<ul>
<li><p>The main interface is <code>IWindow</code>, an interface representing a window. It contains very little of its own, and mostly serves to implement the other <code>IWindow*</code> interfaces for the sake of convenience.</p>
</li>
<li><p>A few properties are implemented here instead of <code>IWindowProperties</code>; this is to avoid forcing <code>WindowOptions</code> to implement them as well, since they aren't needed in that context.</p>
</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Base interface for a window.
/// &lt;/summary&gt;
public interface IWindow : IWindowProperties, IWindowFunctions, IWindowEvents
{
    /// &lt;summary&gt;
    /// A handle to the underlying window.
    /// &lt;/summary&gt;
    IntPtr Handle { get; }

    /// &lt;summary&gt;
    /// If true, the window has failed to reach the target framerate for multiple consecutive frames,
    /// as defined in &lt;see cref=&quot;IWindowProperties.RunningSlowTolerance&quot;/&gt;. You can use this to
    /// do things such as lowering visual fidelity to increase framerates on lower-end machines.
    /// &lt;/summary&gt;
    bool IsRunningSlowly { get; }
}
</code></pre>
<ul>
<li>The first interface is <code>IWindowProperties</code>.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Contains all window properties.
/// &lt;/summary&gt;
public interface IWindowProperties
{
    /// &lt;summary&gt;
    /// If true, both updates and rendering will happen on the same thread. If false, both updating
    /// and rendering will be run on their own threads. Default is true.
    /// &lt;/summary&gt;
    bool UseSingleThreadedWindow { get; }

    /// &lt;summary&gt;
    /// The position of the window. Integer vector. If set to -1, use the backend default.
    /// Default is -1 for both components.
    /// &lt;/summary&gt;
    Point Position { get; set; }

    /// &lt;summary&gt;
    /// The size of the window. Integer vector. Default is 1280 x 720.
    /// &lt;/summary&gt;
    Size Size { get; set; }

    /// &lt;summary&gt;
    /// The number of rendering operations to run per second. If 0, the framerate will be uncapped.
    /// Default is 0.
    /// &lt;/summary&gt;
    double FramesPerSecond { get; }

    /// &lt;summary&gt;
    /// The number of update operations to run per second. If 0, the update rate will be uncapped.
    /// Default is 0.
    /// &lt;/summary&gt;
    double UpdatesPerSecond { get; }

    /// &lt;summary&gt;
    /// The graphics API to use, and associated configurations.
    /// Default is OpenGL 3.3 forward-compatable core profile.
    /// &lt;/summary&gt;
    GraphicsAPI API { get; }
    
    /// &lt;summary&gt;
    /// The title of the window. Default is &quot;Silk.NET Window&quot;.
    /// &lt;/summary&gt;
    string Title { get; set; }
    
    /// &lt;summary&gt;
    /// The state of the window. Default is Normal.
    /// &lt;/summary&gt;
    WindowState WindowState { get; set; }

    /// &lt;summary&gt;
    /// The type of border the window has. Default is Resizable.
    /// &lt;/summary&gt;
    WindowBorder WindowBorder { get; set; }
    
    /// &lt;summary&gt;
    /// The vertical synchronization mode to use. Default is On.
    /// &lt;/summary&gt;
    VSyncMode VSync { get; set; }
	
    /// &lt;summary&gt;
    /// The number of frames the window needs to be running slowly for before
    /// &lt;see cref=&quot;IWindow.IsRunningSlowly&quot;/&gt; is set to true. Default is 5.
    /// &lt;/summary&gt;
    int RunningSlowTolerance { get; set; }
}
</code></pre>
<ul>
<li><p>Next is <code>IWindowFunctions</code>. This is very standard for windows, since most functionality will be provided by users via callbacks.</p>
</li>
<li><p>Certain backends (such as GLFW) have limits as to what functions can be called on threads that the windowing system wasn't initialized. In these cases, <a href="https://github.com/Ultz/Dispatcher">Ultz.Dispatcher</a> should be used as a workaround for multithreading. The <code>Invoke</code> methods provide user-access to the main UI thread.</p>
</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Contains all windowing functions.
/// &lt;/summary&gt;
public interface IWindowFunctions
{
    /// &lt;summary&gt;
    /// Closes this window.
    /// &lt;/summary&gt;
    void Close();

    /// &lt;summary&gt;
    /// Processes pending window events.
    /// &lt;/summary&gt;
    void ProcessEvents();

    /// &lt;summary&gt;
    /// Makes the GraphicsContext current on the calling thread.
    /// &lt;/summary&gt;
    void MakeCurrent();

    /// &lt;summary&gt;
    /// Transforms the specified point from screen to client coordinates.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;point&quot;&gt;
    /// The &lt;see cref=&quot;Point&quot; /&gt; to transform.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// The point transformed to client coordinates.
    /// &lt;/returns&gt;
    Point PointToClient(Point point);

    /// &lt;summary&gt;
    /// Transforms the specified point from client to screen coordinates.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;point&quot;&gt;
    /// The &lt;see cref=&quot;Point&quot; /&gt; to transform.
    /// &lt;/param&gt;
    /// &lt;returns&gt;
    /// The point transformed to screen coordinates.
    /// &lt;/returns&gt;
    Point PointToScreen(Point point);

    /// &lt;summary&gt;
    /// Invokes this delegate on the window's main thread.
    /// &lt;/summary&gt;
    object Invoke(Delegate d);

    /// &lt;summary&gt;
    /// Invokes this delegate on the window's main thread, with the provided arguments.
    /// &lt;/summary&gt;
    object Invoke(Delegate d, params object[] args);
}
</code></pre>
<ul>
<li>Next is <code>IWindowEvents</code>. Several events GLFW provides have been omitted. Everything related to input has been removed, as it would be redundant to have input-handling both here and in <code>Silk.NET.Input</code>. In addition, certain events (such as <code>WindowBorderChanged</code>) have been omitted, as those variables will only ever be updated when the user updates them manually.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Contains all window virtual functions.
/// &lt;/summary&gt;
public interface IWindowEvents
{
    /// &lt;summary&gt;
    /// Raised when the window is moved.
    /// &lt;/summary&gt;
    event Action&lt;Point&gt; Move;

    /// &lt;summary&gt;
    /// Raised when the window is resized.
    /// &lt;/summary&gt;
    event Action&lt;Size&gt; Resize;

    /// &lt;summary&gt;
    /// Raised when the window is about to close.
    /// &lt;/summary&gt;
    event Action Closing;

    /// &lt;summary&gt;
    /// Raised when the window state is changed.
    /// &lt;/summary&gt;
    event Action&lt;WindowState&gt; StateChanged;

    /// &lt;summary&gt;
    /// Raised when the window focus changes.
    /// &lt;/summary&gt;
    event Action&lt;bool&gt; FocusChanged;

    /// &lt;summary&gt;
    /// Raised when the user drops files onto the window.
    /// &lt;/summary&gt;
    event Action&lt;string[]&gt; FileDrop;

    /// &lt;summary&gt;
    /// Raised when the window first begins to run.
    /// &lt;/summary&gt;
    event Action Load;

    /// &lt;summary&gt;
    /// Raised when an update should be run.
    /// &lt;/summary&gt;
    event Action&lt;double&gt; Update;

    /// &lt;summary&gt;
    /// Raised when a frame should be rendered.
    /// &lt;/summary&gt;
    event Action&lt;double&gt; Render;
}
</code></pre>
<ul>
<li><p>The GLFW or Native platforms can't be referenced by the main windowing package. This means that we need to work out our own cross-platform windowing platform management API.</p>
</li>
<li><p>To do so, we add <code>ISilkPlatform</code>. Every windowing platform package must include, at minimum, two classes: An implementation of <code>IWindow</code>, and an implementation of <code>ISilkPlatform</code>.</p>
</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// An interface that provides windowing for its respective .NET platform.
/// &lt;/summary&gt;
public interface ISilkPlatform
{
    /// &lt;summary&gt;
    /// Gets a value indicating whether this &lt;see cref=&quot;ISilkPlatform&quot;&gt; should be used, based on the
    /// current runtime/environment.
    /// &lt;/summary&gt;
    bool IsApplicable { get; }
    
    /// &lt;summary&gt;
    /// Creates a window with the given options.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;opts&quot;&gt;The initial settings this window should open with.&lt;/param&gt;
    /// &lt;returns&gt;An implementation of &lt;see cref=&quot;IWindow&quot;/&gt;&lt;/returns&gt;
    IWindow GetWindow(WindowOptions opts);
}
</code></pre>
<h2 id="classes">Classes</h2>
<ul>
<li>To easily get the proper <code>ISilkPlatform</code> for the current configuration, we add a new static class, <code>Silk</code>, which will automatically select an applicable platform.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Provides methods and properties for configuring Silk.NET's Windowing system. In most cases, the end
/// user shouldn't use this class.
/// &lt;/summary&gt;
public static Silk
{
    /// &lt;summary&gt;
    /// Gets or sets the current windowing platform.
    /// &lt;/summary&gt;
    public static ISilkPlatform CurrentPlatform { get; set; }
    
    /// &lt;summary&gt;
    /// Searches for references to official Silk.NET platforms, and picks the first applicable one for this environment.
    /// applicable one.
    /// &lt;/summary&gt;
    /// &lt;exception cref=&quot;NotSupportedException&quot;&gt;
    /// Thrown if no applicable &lt;see cref=&quot;ISilkPlatform&quot; /&gt; was found.
    /// &lt;/exception&gt;
    public static void Init();
}
</code></pre>
<ul>
<li>To further simplify the process for end users, we add one more new static class, <code>Window</code>, which will wrap the process of getting the proper platform and getting a window from it.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Convenience wrapper for easily creating a Silk.NET window.
/// &lt;/summary&gt;
public static class Window
{
    /// &lt;summary&gt;
    /// Create a window on the current platform.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;options&quot;&gt;The window to use.&lt;/param&gt;
    /// &lt;returns&gt;A Silk.NET window using the current platform.&lt;/returns&gt;
    public static IWindow Create(WindowOptions options);
}
</code></pre>
<ul>
<li>We have our <code>GlfwWindow</code> class. For the purposes of compatability with other backends, there should be as few extra properties that aren't in <code>IWindow</code> as possible.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// A Slim.NET window using the GLFW backend
/// &lt;/summary&gt;
public class GlfwWindow : IWindow
{
	/// &lt;summary&gt;
        /// Create and open a new GlfwWindow.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;options&quot;&gt;The options to use for this window.&lt;/param&gt;
	public GlfwWindow(WindowOptions options);
}
</code></pre>
<h2 id="structs">Structs</h2>
<ul>
<li>To avoid having an excessive number of constructors, and to allow for multiple defaults for multiple situations, we initialize objects Vulkan-style; we fill out a struct with all the properties, and pass that to the constructor.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Contains all window properties, used for window creation.
/// &lt;/summary&gt;
public struct WindowOptions : IWindowProperties
{
    // Contains everything from IWindowProperties,
    // but with setters for all functions that don't have them.

    /// &lt;summary&gt;
    /// Creates a new WindowOptions struct, with sensible defaults.
    /// &lt;/summary&gt;
    public WindowOptions(/*all properties from IWindowProperties*/);

    /// &lt;summary&gt;
    /// Convinience wrapper around creating a new WindowProperties with the default values.
    /// &lt;/summary&gt;
    public static WindowOptions Default =&gt; new WindowOptions(/*sensible defaults*/);
}
</code></pre>
<ul>
<li>All variables related to the graphics API are contained in the <code>GraphicsAPI</code> struct:</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents a configuration for a graphics API.
/// &lt;/summary&gt;
public struct GraphicsAPI
{
    /// &lt;summary&gt;
    /// The render API to use.
    /// &lt;/summary&gt;
    public ContextAPI API { get; set; }

    /// &lt;summary&gt;
    /// The profile to use.
    /// &lt;/summary&gt;
    public ContextProfile Profile { get; set; }

    /// &lt;summary&gt;
    /// Context creation flags.
    /// &lt;/summary&gt;
    public ContextFlags Flags { get; set; }

    /// &lt;summary&gt;
    /// The version of the API to use.
    /// &lt;/summary&gt;
    public APIVersion Version { get; set; }

    /// &lt;summary&gt;
    /// Creates a new GraphicsAPI struct.
    /// &lt;/summary&gt;
    public GraphicsAPI(api, profile, flags, version);

    /// &lt;summary&gt;
    /// The default graphics API. This is OpenGL 3.3 core profile, with forward
    /// compatability enabled.
    /// &lt;/summary&gt;
    public static GraphicsAPI Default =&gt; new GraphicsAPI(ContextAPI.OpenGL,
        ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(3, 3));
}
</code></pre>
<ul>
<li>Since <code>System.Version</code> includes more integers than is necessary for our purposes, a new <code>APIVersion</code> struct was created instead:</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents the desired version of an API.
/// &lt;/summary&gt;
public struct APIVersion
{
    /// &lt;summary&gt;
    /// The major version of the API.
    /// &lt;/summary&gt;
    public int MajorVersion;

    /// &lt;summary&gt;
    /// The minor version of the API.
    /// &lt;/summary&gt;
    public int MinorVersion;

    /// &lt;summary&gt;
    /// Creates a new APIVersion from two integers.
    /// &lt;/summary&gt;
    public APIVersion(int majorVersion, int minorVersion);

    /// &lt;summary&gt;
    /// Creates a new APIVersion from a &lt;see cref=&quot;System.Version&quot;/&gt;
    /// &lt;/summary&gt;
    public APIVersion(Version version);
}
</code></pre>
<h2 id="enums">Enums</h2>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents which API the graphics context should use.
/// &lt;/summary&gt;
public enum ContextAPI
{
    /// &lt;summary&gt;
    /// Don't use any API. This is necessary for linking an external API, such as Vulkan, to the window.
    /// &lt;/summary&gt;
    None = 0,

    /// &lt;summary&gt;
    /// Use Vulkan. Silk.NET doesn't support this yet.
    /// &lt;/summary&gt;
    Vulkan,

    /// &lt;summary&gt;
    /// Use core OpenGL. This is standard for software intended for desktop computers.
    /// &lt;/summary&gt;
    OpenGL,

    /// &lt;summary&gt;
    /// Use OpenGL ES. This is standard for software intended to be compatable with embedded systems,
    /// such as phones.
    /// &lt;/summary&gt;
    OpenGLES
}
</code></pre>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents flags related to the OpenGL context.
/// &lt;/summary&gt;
[Flags]
public enum ContextFlags
{
    /// &lt;summary&gt;
    /// No flags enabled.
    /// &lt;/summary&gt;
    Default = 0,

    /// &lt;summary&gt;
    /// Enables debug context; debug contexts provide more debugging info, but can run slower.
    /// &lt;/summary&gt;
    Debug = 1,

    /// &lt;summary&gt;
    /// Enables forward compatability; this context won't support anything marked as deprecated
    /// in the current
    /// version.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;On OpenGL contexts older than 3.0, this flag does nothing.&lt;/remarks&gt;
    ForwardCompatible = 2
}
</code></pre>
<ul>
<li>Despite GLFW supporting a &quot;don't care&quot; option for the profile, we decided not to include it in the surface API; allowing the backend to choose the profile could introduce platform inconsistencies.</li>
</ul>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents the context profile OpenGL should use.
/// &lt;/summary&gt;
public enum ContextProfile
{
    /// &lt;summary&gt;
    /// Uses a core OpenGL context, which removes some deprecated functionality.
    /// &lt;/summary&gt;
    Core = 0,

    /// &lt;summary&gt;
    /// Uses a compatability OpenGL context, allowing for some deprecated functionality. This should
    /// only ever be used for maintaining legacy code; no newly-written software should use this.
    /// &lt;/summary&gt;
    Compatability
}
</code></pre>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// The vertical synchronization mode to use.
/// &lt;/summary&gt;
public enum VSyncMode
{
    /// &lt;summary&gt;
    /// VSync is disabled.
    /// &lt;/summary&gt;
    Off = 0,
        
    /// &lt;summary&gt;
    /// VSync is enabled.
    /// &lt;/summary&gt;
    On,

    /// &lt;summary&gt;
    /// Use adaptive VSync. If the window IsRunningSlowly, VSync will be disabled. Otherwise,
    /// it will be enabled. If the framerate is uncapped, this is the same as &lt;see cref=&quot;On&quot;/&gt;. 
    /// &lt;/summary&gt;
    Adaptive,
}
</code></pre>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents the window border.
/// &lt;/summary&gt;
public enum WindowBorder
{
    /// &lt;summary&gt;
    /// The window can be resized by clicking and dragging its border.
    /// &lt;/summary&gt;
    Resizable = 0,

    /// &lt;summary&gt;
    /// The window border is visible, but cannot be resized. All window-resizings must happen
    /// solely in the code.
    /// &lt;/summary&gt;
    Fixed,

    /// &lt;summary&gt;
    /// The window border is hidden.
    /// &lt;/summary&gt;
    Hidden
}
</code></pre>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Represents the current state of the window.
/// &lt;/summary&gt;
public enum WindowState
{
    /// &lt;summary&gt;
    /// The window is in its regular configuration.
    /// &lt;/summary&gt;
    Normal = 0,

    /// &lt;summary&gt;
    /// The window has been minimized to the task bar.
    /// &lt;/summary&gt;
    Minimized,

    /// &lt;summary&gt;
    /// The window has been maximized, covering the entire desktop, but not the taskbar.
    /// &lt;/summary&gt;
    Maximized,

    /// &lt;summary&gt;
    /// The window has been fullscreened, covering the entire surface of the monitor.
    /// &lt;/summary&gt;
    Fullscreen
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Ultz/Silk.NET/blob/01e38d37d38f4a667ea63be6f8386c027c6ab569/documentation/proposals/Proposal - Windowing.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
